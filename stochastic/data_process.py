import numpy as np
import matplotlib.pyplot as plt
import pickle
import matplotlib.animation as animation


def produce_ani_frames(path, history_times, sampling_rate, names, history):
    """
    Produce a sequence of .png frames with an animation showing filament positions, species concentrations and an image
    of filament states.
    :param path: path to save frames to. Frames as saved as this string followed by a number, starting with 0.
    :param history_times: times at every time step of the simulation
    :param sampling_rate: tuple (A, B). A is the number of steps between concentration and system size samples. B is the
    tiem between filament states samples.
    :param names: a list of the names of species. Only the first two will be used.
    :param history: a dictionary holding the history of concentration, size, filaments and positions, as generated by the
    System instance. Concentration and size samples must be every A steps. Filament samples every B units of time. Position
    samples must be every step.
    """

    history_concs, history_size, history_filaments, history_positions = history.values()

    fig = plt.figure(constrained_layout=True)
    gs = fig.add_gridspec(5, 4)

    ax1 = fig.add_subplot(gs[0, :2])
    ax2 = fig.add_subplot(gs[1, :2])
    ax3 = fig.add_subplot(gs[2:, :2])
    ax4 = fig.add_subplot(gs[:, 2:])

    x, y = history_times[::sampling_rate[0]], history_concs.T / history_size
    line_plots([ax1, ax2], x, y, ylabel='Concentration', titles=names[:2], lw=0.8)

    positions, times, timeframes = process_positions(history_positions, history_times)
    position_plot(ax3, positions, times, ylabel='Displacement from origin',
                  xlabel='Time', title='Strand positions', alpha=0.2)
    ax3.set_ylabel('Displacement from origin')
    update_alphas(0, ax3.lines, timeframes, 0.6, 0.15, sampling_rate[1])

    ax1.axvline(0.05, color='black', alpha=0.5)
    ax2.axvline(0.05, color='black', alpha=0.5)
    ax3.axvline(0.05, color='black', alpha=0.5)

    break_point = np.isnan(history_filaments).all(axis=(1, 2)).argmax()
    length = break_point if break_point != 0 else len(history_filaments)
    for i, frame in enumerate(history_filaments[:length]):
        print('Progress: {} / {}'.format(i + 1, length))
        time = (i + 1) * sampling_rate[1]

        coords = [[time] * 2, [0, 1]]
        ax1.lines[-1].set_data(coords)
        ax2.lines[-1].set_data(coords)
        ax3.lines[-1].set_data(coords)

        update_alphas(time, ax3.lines[:-1], timeframes, 0.6, 0.15, sampling_rate[1])

        plt.sca(ax4)
        plt.cla()
        ax4.imshow(frame.T[::-1], animated=True)

        plt.savefig(path + str(i))


def preview_graphs(history_times, sampling_rate, names, history):
    """
    Display graphs as they are included in the produce_ani_frames function.
    :param history_times: times at every time step of the simulation
    :param sampling_rate: tuple (A, B). A is the number of steps between concentration and system size samples. B is the
    time between filament states samples.
    :param names: a list of the names of species. Only the first two will be used.
    :param history: a dictionary holding the history of concentration, size, filaments and positions, as generated by the
    System instance. Concentration and size samples must be every A steps. Filament samples every B units of time. Position
    samples must be every step.
    """
    history_concs, history_size, history_filaments, history_positions = history.values()

    fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True)

    x, y = history_times[::sampling_rate[0]], history_concs.T / history_size
    line_plots([ax1, ax2], x, y, ylabel='Concentration', titles=names[:2], lw=0.8)
    plt.show()

    fig, ax = plt.subplots()
    positions, times, _ = process_positions(history_positions, history_times)
    position_plot(ax, positions, times, alpha=0.2)
    plt.show()

    plt.figure()
    plt.plot(x, history_size)

    fig, ax = plt.subplots()
    ims = []
    for frame in history_filaments:
        print(len(ims))
        if np.isnan(frame).all():
            break
        im = plt.imshow(frame.T[::-1], animated=True)
        ims.append([im])
    ani = animation.ArtistAnimation(fig, ims, interval=50)
    plt.show()


def line_plots(axes, xdata, ydata, xlabel=None, ylabel=None, titles=None, **kwargs):
    """
    Draw lines on a set of axes.

    :param axes: a list of length N, containing the axes objects where to plot the graphs
    :param xdata: an array of length L, with the times at which the ydata was obtained
    :param ydata: an array of length NxL, with the y values to be plotted for every axis
    :param xlabel: xlabel to apply to all graphs
    :param ylabel: ylabel to apply to all graphs
    :param titles: a list of length N, with titles to apply to graphs
    :param kwargs: keywords to pass to the plotting function
    """
    if titles is None:
        titles = [None] * len(axes)

    assert len(axes) == len(ydata), 'Axes and ydata must have same first dimension'
    assert len(axes) == len(titles), 'Axes and titles must have same length'

    for axis, y, title in zip(axes, ydata, titles):
        axis.plot(xdata, y, **kwargs)

        if xlabel is not None:
            axis.set_xlabel(xlabel)
        if ylabel is not None:
            axis.set_ylabel(ylabel)
        if title is not None:
            axis.set_title(title)


def process_positions(positions, times):
    """
    Takes an array of histories of filament positions and outputs a list of arrays with the per filament
    trajectories. Lack of filament at that slot requires it to be np.nan. At lower sampling frequencies a filament's
    disappearance might not detected if it is quickly replaced.
    :param positions: a 2D array of shape TxL, with T being the number of samples taken and L being the number of filament
    slots.
    :param times: a 1D array of length T, with each element being the time at which the samples in positions were taken.
    :return: lists of positions and times for every filament. Also lists of when filaments are created and destroyed.
    """
    pos_histories = []
    time_histories = []
    start_histories = []
    end_histories = []
    for slot_history in positions.T:
        nan_bools = np.isnan(slot_history)

        ends = np.full(nan_bools.shape, ~nan_bools[-1])
        ends[:-1] = nan_bools[1:] * (~nan_bools[:-1])

        starts = np.full(nan_bools.shape, ~nan_bools[0])
        starts[1:] = (~nan_bools[1:]) * nan_bools[:-1]

        start_pos = starts.nonzero()[0]
        end_pos = ends.nonzero()[0]

        for s, e in zip(start_pos, end_pos):
            pos_histories.append(slot_history[s:e + 1])
            time_histories.append(times[s:e + 1])
            start_histories.append(times[s])
            end_histories.append(times[e])

        timeframes = np.array(start_histories), np.array(end_histories)
    return pos_histories, time_histories, timeframes


def update_alphas(time, lines, timeframes, alpha1, alpha2, period):
    """
    Update the alpha parameter of lines of a plot, depending on the time. Used during animation.
    :param time: the time the animation is at
    :param lines: a list of length N of Line2D instances to modify
    :param timeframes: a tuple of arrays of length N. The first array is the times at which alpha should be set to alpha1.
    The second array is the times at which alpha should be set to alpha2.
    :param alpha1: value of alpha
    :param alpha2: value of alpha
    :param period: the length of time that occurs between function calls.
    """
    starts, ends = timeframes

    changed = (starts <= time) * (starts > time - period)
    indices = np.nonzero(changed)[0]
    for index in indices:
        lines[index].set_alpha(alpha1)

    changed = (ends <= time) * (ends > time - period)
    indices = np.nonzero(changed)[0]
    for index in indices:
        lines[index].set_alpha(alpha2)


def position_plot(axis, positions, times, xlabel=None, ylabel=None, title=None, **kwargs):
    """
    Make a plot of the positions of all filaments with time. :param axis: axis where the plot is drawn
    :param positions: a list of length N, holding arrays storing the position of each filament. As produced by
    process_positions
    :param times: a list of length N, holding arrays with te time at which each position was held. As produced by
    process_positions
    :param xlabel: xlabel to apply to the graph
    :param ylabel: ylabel to apply to the graph
    :param title: title to apply to the graph
    :param kwargs: keywords to pass to the plotting function
    """
    color = plt.rcParams['axes.prop_cycle'].by_key()['color'][0]
    for pos, t in zip(positions, times):
        axis.plot(t, pos, color=color, **kwargs)

    if xlabel is not None:
        axis.set_xlabel(xlabel)
    if ylabel is not None:
        axis.set_ylabel(ylabel)
    if title is not None:
        axis.set_title(title)


def save(path, times, sampling_rate, names, history):
    """
    Pickle all data needed to call produce_ani_frames or preview_graphs
    """
    file = open(path, 'wb')
    pickle.dump(times, file)
    pickle.dump(sampling_rate, file)
    pickle.dump(names, file)
    pickle.dump(history, file)
    file.close()


def load(path):
    """
    Load all data needed to call produce_ani_frames or preview_graphs. e.g. preview_graphs(*load(path))
    """
    file = open(path, 'rb')
    times = pickle.load(file)
    sampling_rate = pickle.load(file)
    names = pickle.load(file)
    history = pickle.load(file)
    file.close()
    return times, sampling_rate, names, history